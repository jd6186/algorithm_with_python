# 출처: https://rebas.kr/666 [PROJECT REBAS]

def next_permutation(a):
    
    # index번호 n구하기
    n = len(a) - 1
    
    
    
    ###############################
    
    
    
    # 인덱스번호를 활용해 a[i]값보다 큰값이 있는지 없는지 인덱스를 타고 내려가면서 확인한다. 
    # 왜? i값이 0이 되었다는것은 수가 완전히 역수로 정렬되었다는 것이 때문에 가장 큰값 즉, -1을 리턴해줘야하는 상황이라는 것이다.
    # 또한 이 과정을 통해 배열의 뒤에서 부터 찾았을 때 가장 처음 나오는 배열 앞뒤 값보다 큰 값의 위치를 찾기 위함이다. 
    # 이렇게 하는 이유는 그 값의 위치를 뒤쪽에 존재하는 값과 위치를 바꿔야 바로 다음 큰수가 되기 때문이다.
    
    # 여기서 
    # 1) [6 5 3 4 2 1]과 
    # 2) [6 5 3 4 1 2],
    # 3) [1 5 4 2 3 6]가 있을 때를 서로 비교
    
    # 1)은 a[i]라고 하면 a[n-1] >= a[n]이므로 2 >= 1가 된다.
    # 그러다가 a[(n-2)-1] >= a[(n-2)] 이 되었을 때  3 >= 4이므로 멈추게 된다.
    # 2), 3)은 바로 False가 되면서 다음으로 넘어가게 된다.
    i = n
    while i > 0 and a[i-1] >= a[i]:
        i -= 1
    # 현재 i의 값은 최초 5에서 -2된 3
    
    
    ###############################
    
    
    
    # 1), 2), 3) 둘다 해당 조건에 부합하지 않는다. 따라서 패스
    if i == 0:
        return False
    
    
    
    ###############################
    
    
    
    # 지금 1)의 i는 3이며 2)의 i는 5인상황
    # j은 5로 초기화한다.
    j = n
    
    # 1)의 a[3-1]의 값은 3이며 a[5]의 값은 1
    # 2)의 a[5-1]의 값은 1이며 a[5]의 값은 2
    while a[i-1] >= a[j]:
        j -= 1
    # 따라서 여기서
    # 1)의 j값은 -2된 3이된다.
    # 2)의 j값은 변화 없는 5이다.
    
    
    ###############################
    
    
    # 1)의 변화 = a[2], a[3] = a[3], a[2]
    # 2)의 변화 = a[4], a[5] = a[5], a[4]
    # 2)의 변화 = a[4], a[5] = a[5], a[4]
    a[i-1], a[j] = a[j], a[i-1]
    # [6 5 3 4 2 1] 보다 바로 다음으로 큰 수는
    # [6 5 4 3 2 1]이다.
    
    # [6 5 3 4 1 2] 일 경우는
    # [6 5 3 4 2 1] 이다.
    
    # [1 5 4 2 3 6] 일 경우
    # [1 5 4 2 6 3]
    
    # 이로서 이미 바로 다음으로 큰 수를 구한 상황
    
    ###############################
    
    
    
    # 다시 j값을 초기화 시키기고
    j = n
    # 현재
    # 1) i = 3이며 j도 3인 상황이므로 false로 여기도 넘어간다.
    # 2) i = 5이며 j도 5인 상황이므로 false로 여기도 넘어간다.
    # 3) i = 5이며 j도 5인 상황이므로 false로 여기 넘어간다.
    while i < j:
        a[i], a[j] = a[j], a[i]
        i += 1
        j -= 1
    
    # 하지만 1 2 4 3 6 5 같은수는  한번더 바꾸는 과정이 필요하다. 그래서 이런 과정을 겪는 것
    # 다 떠나서 이거 없어도 작동한다. 왜 쓴거지?
    
    ###############################
    
    
    # 그후 return True가 되면서 값이 나가게 된다.
    return True



n = int(input())
a = list(map(int, input().split()))

if next_permutation(a) is True:
    for i in a:
        # 위 과정을 거치면 여기서는 1 2 4 3이 출력되게 된다.
        print(i, end=' ')
    print()
else:
    print(-1)
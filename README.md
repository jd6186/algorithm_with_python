# algorithm_with_python이란?
파이썬을 활용해 알고리즘 유형별로 풀어본 결과를 남기는 곳입니다.


# 과정
과정은 크게 4가지로 나누었습니다.
1. 문제 풀기 전 문제를 분석한 내용
2. 내가 문제를 푼 코드
3. 다른 사람들이 푼 코드들 중 가장 효율적이라고 생각되는 코드
4. 내가 이문제를 접근 할 때 고려했어야하는 마인드셋


# 문제 유형
1. 브루트 포스
2. 브루트 포스 (N과 M 연습)
3. 그래프와 BFS
4. 다이나믹 프로그래밍


# 1. 브루트 포스


1. 일곱 난쟁이(https://www.acmicpc.net/problem/2309)

**(1) 문제 분석**
[문제 내용]
왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다. 
일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다.
아홉 명의 난쟁이는 모두 자신이 "백설 공주와 일곱 난쟁이"의 주인공이라고 주장했다. 

뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.
아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오. 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.


[문제 접근하기]
난쟁이는 7명만 존재
7명의 합은 100
9난쟁이의 키가 주어질 때 7난쟁이를 찾는 프로그램 제작해라

방법1.
9명의 키는 리스트로 주어지지 않고 그냥 1개씩 들어온다. 따라서 총 9번 도는 for문을 돌려야한다. 
값을 받았다면 배열에 넣고 7개를 더한 값이 100이 되는 조합을 찾아야한다.

방법2.
우선 값을 7명까지 받았을 때 전부 더해본다. 100이되지 않는다면 안에 있는 값을 새로들어오는 값 즉, 8번째 값과 1개씩 넣다 뺐다하며 다시 값을 7개로 만들어 합해본다.
그렇게해서 값이 100이나오는 경우가 있다면 바로 Return


지금은 2번이 더 효율적이라 판단되니 2번으로 해보겠다.
우선 length가 7일 때 전체 값의 합 구해서 100이면 return arr
length가 7보다 클 때 반복문 돌려서 arrTest[i]를 계속 새로운 값을 넣어보면서 100이되는게 있나 찾기 있으면 바로 return arr

```
i = 0
arr = []
arrTest = []
while(i < 9):
  if(len(arr) == 7):
      j = 0
      for j in range(0, len(arr), 1):
          addNum = int(input())
          arr[j] = addNum
          if(arr.sum() == 100):
              return arr
          else:
              continue          
                    
  arr.append(int(input()))
  if(len(arr) >= 7):
    if(arr.sum == 100):
      return arr
    elif(): 
        continue
```

// 문제를 풀다 발견된 문제점 이렇게 할 경우 8번째 숫자가 입력되었을 때 값이 있다면 다행이지만 9번째 숫자가 반드시 필요하다면 문제가 복잡해진다.
// 8번째와 9번째 숫자가 모두 필요할 수도 있고 9번째만 필요할 수도 있기 때문에 경우의 수가 너무 복잡해진다.

// 결국 다른 방법 필요
// 일일이 구하는건? 
```
i = 0
arr = []
# 값 받기
for i in range(0, 9, 1):
    arr.append(int(input()))

# 값 정렬
arr.sort(key=None, reverse=True)

# 값 분석
for j in range(0, 3, 1):
    print("몇 회차니? : ", j)
    arrT = [arr[j]]
    sums = arr[j]
    k = j+1
    while(True):
        print("몇 회차니? : ", j, " 그리고  ", k+6)
        if(k+6 > len(arr)):
            break
        for z in range(k, k+6, 1):
            sums = sums + arr[z]
            arrT.append(arr[z])
        print(sums)
        if(sums != 100):
            arrT = [arr[j]]
            sums = arr[j]
            k += 1
            continue
        elif(sums == 100) :
            print("결과값 : ",arrT)
            break
    if(sums == 100):
        break
    else :
        continue
```

// 이것도 아니다. 이렇게 구할 수 없을 뿐더러 분명히 시간초과다.
// 다른 접근 방법이 필요한데 이제 이 문제의 유형인 브루트 포스에 대해 알아보자

* 브루트 포스란?
* 이산수학 또는 수리논리학으로서 
* 조합 가능한 모든 문자열을 하나씩 대입해 보는 방식으로 암호를 해독하는 방법이라는 뜻이다. 
* 하지만 이런 방법은 엄청난 시간복잡도를 야기 시키기 때문에 대부분 동적계획법(DP = Dynamic Programming)으로 변환하고 있는 추세이다.


자 이제 위 개념을 가지고 문제를 어떤 식으로 접근해볼까요?
우선 이 파트 자체가 브루트포스를 연습하는 파트기 때문에 전체 순회를 하며 문제를 해결하는게 맞다고 보여지죠?
그럼 구조는 간단합니다

기준값 선정
  기준값을 제외한 모든 원소와의 조합을 계산하여 합이 100인 숫자 찾기
  있다면 그 조합을 return
  다 순회해도 없다면 다음 값으로 넘어가기
 
이 구조로 짜주면 될 것 같습니다. 한 번 시도 해 보겠습니다.

아무리 생각해도 7중 for문을 돌리는 것 밖에 생각이 들지 않아서 다른분들 내용을 참고해보겠습니다.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

**(2)문제 풀이 코드**
풀기 실패

**(3) 가장 효율적인 문제 풀이 코드**

```
# 출처 : https://daimhada.tistory.com/163

arr = []
# 값 받기 
for i in range(9):
    arr.append(int(input()))

# 값 계산하기 이부분이 중요! 7명을 계산해서 100을 만들어 내는게 아니고 
# 전체 합값에서 2명을 빼서 100이나오는 것을 찾는거야 이후 코드를 보자
res = sum(arr)

# 값 정렬하기
# arr.sort(key=None, reverse=False) 
# 이걸 작성하셨던데 이건 그냥 빼는게 시간복잡도를 떨어뜨리는 길이다... 어차피 모든 수를 봐야하기 때문에 이건 의미가 없다. 왜하셨지..

# 배열 순환하며 값찾기 인자가 2개밖에 없으므로 2중 for문이면 가능하다.
for i in range(9):
    for j in range(i+1, 9):
        if(res - arr[i] - arr[j] == 100):
            #여기서 나온 for문은 그냥 문자 출력용 for문
            for k in range(9):
                if(k == i or k == j):
                    continue
                else :
                    print(arr[k])
 ```       

**(4) 고려했어야하는 마인드 셋**

어떻게 하면 가장 적은 반복회수를 가질 것인지 판단했어야하는데 전체 경우의 수를 모두 사용해야한다는 생각에 사로잡혀 근시한적인 사고를 가지고 있었음
이렇게 브루트 포스 문제를 풀 때는 미지수의 개수 자체를 줄이는 방법을 먼저 고려해야한다는 것을 깨달음



2. 날짜 계산
**(1) 문제 분석**
[문제 내용]

[문제 접근하기]



**(2) 문제 풀이 코드**

**(3) 가장 효율적인 문제 풀이 코드**

**(4) 고려했어야하는 마인드 셋**







3. 테트로미노
(1) 문제 분석

(2) 문제 풀이 코드

(3) 가장 효율적인 문제 풀이 코드

(4) 고려했어야하는 마인드 셋







4. 1, 2, 3 더하기
(1) 문제 분석

(2) 문제 풀이 코드

(3) 가장 효율적인 문제 풀이 코드

(4) 고려했어야하는 마인드 셋







5. 다음 순열
(1) 문제 분석

(2) 문제 풀이 코드

(3) 가장 효율적인 문제 풀이 코드

(4) 고려했어야하는 마인드 셋







6. 이전 순열
(1) 문제 분석

(2) 문제 풀이 코드

(3) 가장 효율적인 문제 풀이 코드

(4) 고려했어야하는 마인드 셋







7. 모든 순열
(1) 문제 분석

(2) 문제 풀이 코드

(3) 가장 효율적인 문제 풀이 코드

(4) 고려했어야하는 마인드 셋







8. 차이를 최대로
(1) 문제 분석

(2) 문제 풀이 코드

(3) 가장 효율적인 문제 풀이 코드

(4) 고려했어야하는 마인드 셋







9. 외판원 순회 2
(1) 문제 분석

(2) 문제 풀이 코드

(3) 가장 효율적인 문제 풀이 코드

(4) 고려했어야하는 마인드 셋







10. 로또
(1) 문제 분석

(2) 문제 풀이 코드

(3) 가장 효율적인 문제 풀이 코드

(4) 고려했어야하는 마인드 셋







11. 연산자 끼워넣기
(1) 문제 분석

(2) 문제 풀이 코드

(3) 가장 효율적인 문제 풀이 코드

(4) 고려했어야하는 마인드 셋







12. 암호 만들기
(1) 문제 분석

(2) 문제 풀이 코드

(3) 가장 효율적인 문제 풀이 코드

(4) 고려했어야하는 마인드 셋







13. 부분집합의 합
(1) 문제 분석

(2) 문제 풀이 코드

(3) 가장 효율적인 문제 풀이 코드

(4) 고려했어야하는 마인드 셋







14. 퇴사
(1) 문제 분석

(2) 문제 풀이 코드

(3) 가장 효율적인 문제 풀이 코드

(4) 고려했어야하는 마인드 셋







15. 연산자 끼워넣기 (2)
(1) 문제 분석

(2) 문제 풀이 코드

(3) 가장 효율적인 문제 풀이 코드

(4) 고려했어야하는 마인드 셋







16. 집합
(1) 문제 분석

(2) 문제 풀이 코드

(3) 가장 효율적인 문제 풀이 코드

(4) 고려했어야하는 마인드 셋







# 2. 브루트 포스 (N과 M 연습)
# 3. 그래프와 BFS
# 4. 다이나믹 프로그래밍
